package com.elex.tasks.base{	import flash.display.DisplayObjectContainer;	import flash.events.EventDispatcher;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getQualifiedClassName;
			/**	 * Abstract class for command implementations. A command encapsulates code that can be	 * instantiated and executed anywhere else in the application.<p>Commands can either be	 * executed without event listening if their execution code is processed synchronous or	 * a command can be listened to for events that are broadcasted by the command when the	 * it completes, an error occurs or during command progress steps.	 * 	 * @author longyangxi	 */		[Event(type="com.elex.tasks.base.TaskEvent",name="task_complete")]	[Event(type="com.elex.tasks.base.TaskEvent",name="task_progress")]	[Event(type="com.elex.tasks.base.TaskEvent",name="task_abort")]	[Event(type="com.elex.tasks.base.TaskEvent",name="task_error")]	public class Task extends EventDispatcher	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////		//用户自定义数据		public var data:Object;		/** @private */		protected var _listener:ITaskListener;		/** @private */		protected var _isAborted:Boolean;		protected var _hasError:Boolean;		protected var _isCompleted:Boolean;				/** @private */		protected var _completed:Number;		protected var _total:Number;		/**		 * 这个命令的描述，会出现在progressPanel上		 * */		protected var _progressMsg:String="";		////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new Task instance.		 * @parame delay: 延迟多少毫秒执行		 * @param timeOut:执行时间不能超过多少秒		 * @parm  retryCount:如果出现错误或超时，重试次数		 */		public function Task(delay:uint=0,timeOut:uint=999999,retryCount:uint=3)		{			this._delay=delay;			this._timeout=timeOut;			this._retryCount=retryCount			super();		}				public function get progressMsg():String		{			return _progressMsg;		}		public function set progressMsg(msg:String):void		{			this._progressMsg=msg;		}		protected var _progressPanelParent:DisplayObjectContainer;		protected var _modal:Boolean=true;		/**		 * 显示进度框，暂时在非flex项目里不能用		 * *///		public function showProgressPanel(parent:DisplayObjectContainer,modal:Boolean=true):ProgressPanel//		{//			_progressPanelParent=parent//			_modal=modal;//			return showProgress();//		}//		protected function showProgress():ProgressPanel//		{//			if(_progressPanelParent&&(!_isAborted)){//				return ProgressManager.show(_progressPanelParent,this._progressMsg,_modal);//			}//			return null;//		}		public function hideProgressPanel():void		{//			if(_progressPanelParent){//				ProgressManager.hide(_progressPanelParent,this._progressMsg);//				_progressPanelParent=null;//			}		}		/**		 * The Task's progress.		 */		public function get completed():Number		{			return _completed;		}		public function get total():Number		{			return _total;		}		/**		 * Executes the Task. In sub-classed Tasks you should override this		 * method, make a call to super.execute and then initiate all your Task's		 * execution implementation from here.		 */ 		final public function execute():void		{			if(!_paused) return;			if(_delay<=0) this.doExecute();			else {				var t:Timer=new Timer(_delay,1);				var callBack:Function=this.doExecute;				t.addEventListener(TimerEvent.TIMER_COMPLETE,function(e:TimerEvent):void{callBack()});				t.start();				trace("Task->execute: ","The task will start "+_delay/1000+" seconds later!");			}		}		/**		 * 确实执行之		 * */		protected function doExecute():void		{			_isAborted = false;			_hasError=false;			_isCompleted=false;			_paused=false;			_completed = 0;			_total=1;					if(this._timeout>0) this.startTimer();		}		protected var _paused:Boolean=true;		/**		 * Pauses or unpauses the task.		 */		public function get paused():Boolean		{			return _paused;		}		public function set paused(v:Boolean):void		{			_paused = v;		}				/**		 * Aborts the Task's execution. Any sub-classed implementation needs		 * to take care of abort functionality by checking the _aborted property.		 */		public function abort():void		{			_isAborted = true;		}						/**		 * Returns a string representation of the Task.		 * @return A string representation of the Task.		 */		override public function toString():String		{			return "[" + getQualifiedClassName(this).match("[^:]*$")[0]				+ ", name=" + name + "]";		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * returns the name identifier of the Task. Names are mainly used for the		 * Task to be identified when it should be able to be executed through the CLI.		 * This is an abstract method which needs to be overriden in sub classes to		 * give it a unique Task name.		 * 		 * @return the name identifier of the Task.		 */		public function get name():String		{			return "Task";		}						/**		 * Gets or sets the object that listens to events fired by this Task. This		 * can be used as a shortcut. The listener has to implement the ITaskListener		 * interface to be able to use this.		 * 		 * @return The object that listens to events fired by this Task.		 */		public function get listener():ITaskListener		{			return _listener;		}		public function set listener(v:ITaskListener):void		{			_listener = v;		}		/**		 * 侦听progressEvent事件，为此Task所用		 * 需要添加侦听器		 * */		public function captureProgressEvent(e:ProgressEvent):void		{			this._completed=e.bytesLoaded;			this._total=e.bytesTotal;			this.notifyProgress();		}		/**		 * Gets the abort state of the Task.		 */		public function get isAborted():Boolean		{			return _isAborted;		}		public function get hasError():Boolean		{			return _hasError;		}		public function get isCompleted():Boolean		{			return _isCompleted;		}				////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////		/**		 * Notify listeners that the Task has updated progress.		 * @private		 */		/**		 * Notifies listeners that the command has completed.		 * 		 * @private		 */		private function notifyComplete():void		{			_isCompleted=true;			_paused=true;//		     hideProgressPanel();			dispatchEvent(new TaskEvent(TaskEvent.TASK_COMPLETE, this));			trace("Task->notifyComplete: ","Excute task: "+this.toString()+" successfully!");		}						/**		 * Notifies listeners that the task was aborted.		 * 		 * @private		 */		private function notifyAbort():void		{			_paused=true;//			hideProgressPanel();			dispatchEvent(new TaskEvent(TaskEvent.TASK_ABORT, this));			trace("Task->notifyAbort: ","Task: "+this.toString()+" aborted!");		}									protected function notifyProgress(task:Task=null):void		{			if(task==null) task=this;//            if(this._progressPanelParent&&(command==this)) {//				ProgressManager.setProgress(_progressPanelParent,command.progressMsg,command.completed,command.total);//			}						dispatchEvent(new TaskEvent(TaskEvent.TASK_PROGRESS, task,				task.progressMsg));		}				/**		 * Notifies listeners that an error has occured while executing the TASK.		 * 		 * @private		 * @param errorMsg The error message to be broadcasted with the event.		 */		protected function notifyError(errorMsg:String):void		{			if(_hasError) return;			this._currentRetry++;			this.killTimer();			if(!this.retryOver){				this.doExecute();				return;				}			_hasError=true;			_paused=true;//			 hideProgressPanel();			dispatchEvent(new TaskEvent(TaskEvent.TASK_ERROR, this, errorMsg));			trace("Task->notifyError: ",errorMsg);			_currentRetry=0;		}						/**		 * Completes the task. This is an abstract method that needs to be overridden		 * by subclasses. You put code here that should be executed when the task		 * finishes, like cleaning up event listeners etc. After your code, place a call		 * to super.complete().		 * 		 * @private		 */		protected function complete():void		{			if (!_isAborted) notifyComplete();			else notifyAbort();			this.killTimer();			_currentRetry=0;		}				////////////////////////////////////////////////time out handle//////////////////////////////////////////////////		/**		 * Starts the timer that is used to manage timeouts and retries		 */		//延迟执行时间		protected var _delay:uint=0;		// 任务执行的时间限制		protected var _timeout:uint =999999;				// 如果出现错误，重试次数		protected var _retryCount:uint =0;		protected var _currentRetry:int=0;		protected var _executeTimer:Timer;				protected function startTimer():void 		{			_executeTimer = new Timer(timeout * 1000, 1);			_executeTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onFinalTimeOut);			_executeTimer.start();		}		/**		 * Stops the timer used to manage timeouts and retries		 */		protected function killTimer():void 		{			if(_executeTimer == null) return;			_executeTimer.stop();			_executeTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onFinalTimeOut);		}		/**		 * If Timer has expired, we have completed all retries.  Kill it.		 */		private function onFinalTimeOut(event:TimerEvent):void 		{			this.killTimer();			this._currentRetry++;			if(!this.retryOver) this.doExecute();			else this.notifyError("This task has retried for "+this._retryCount+" times and failed!");		}		protected function get retryOver():Boolean		{			return this._currentRetry>=_retryCount;		}		/**		 * Timeout in seconds		 */		public function get timeout():uint {			return _timeout;		}		public function set timeout(t:uint):void{			this._timeout=t;		}		/**		 * Number of times to retry request if it is timing out		 */		public function get retryCount():uint {			return _retryCount;		}		public function set retryCount(r:uint):void{			this._retryCount=r;		}		public function get delay():uint {			return _delay;		}		public function set delay(d:uint):void{			this._delay=d;		}			}}